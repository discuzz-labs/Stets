// Generated by dts-bundle-generator v9.5.1

import { Plugin as Plugin$1 } from "esbuild";
import { SourceMapConsumer } from "source-map";
import "./global";

export interface LogEntry {
	type: string;
	args: any[];
}
export interface ErrorMetadata {
	message: string;
	stack?: string;
}
export interface ErrorInspectOptions {
	error: ErrorMetadata | Error;
	file?: string;
	sourceMap?: SourceMapConsumer;
	noColor?: boolean;
}
export declare class ErrorInspect {
	private static readonly STACK_FRAME_REGEX;
	private static readonly CONTEXT_LINES;
	private static colorize;
	private static line;
	private static parse;
	private static stack;
	private static context;
	private static buildMessage;
	static format(options: ErrorInspectOptions): string;
}
export interface BenchmarkMetrics {
	meanLatency: number;
	medianLatency: number;
	p95Latency: number;
	stdDev: number;
	opsPerSecond: number;
	confidenceInterval: {
		lower: number;
		upper: number;
	};
	samples: number;
	timestamp: number;
	timedOut: boolean;
}
export type TestFunction = () => void | Promise<void>;
export type HookFunction = () => void | Promise<void>;
export type Status = "passed" | "failed" | "softfailed" | "skipped" | "todo";
export type TestCaseStatus = "passed" | "failed" | "pending" | "empty";
export type HookTypes = "afterAll" | "afterEach" | "beforeAll" | "beforeEach";
export interface Test {
	description: string;
	fn: TestFunction;
	options: Options;
}
export interface Hook {
	description: HookTypes;
	fn: HookFunction;
	options: Options;
}
export type TestResult = {
	description: string;
	status: Status;
	retries: number;
	duration: number;
	error?: ErrorMetadata;
	bench: BenchmarkMetrics | null;
};
export type HookResult = {
	description: HookTypes;
	status: Status;
	retries: number;
	duration: number;
	error?: ErrorMetadata;
	bench: null;
};
export interface Stats {
	total: number;
	skipped: number;
	passed: number;
	failed: number;
	softfailed: number;
	todo: number;
}
export interface TestReport {
	stats: Stats;
	description: string;
	status: TestCaseStatus;
	tests: TestResult[];
	hooks: HookResult[];
}
/**
 * Interface representing configuration options for a test case.
 */
export interface Options {
	/**
	 * The maximum time (in milliseconds) a test is allowed to run before timing out.
	 * @type {number}
	 * @example 5000 // 5 seconds timeout
	 */
	timeout: number;
	/**
	 * Indicates whether the test should be skipped.
	 * @type {boolean}
	 * @example true // Test will be skipped
	 */
	skip: boolean;
	/**
	 * A condition to determine whether the test should run.
	 * Can be a boolean, a function returning a boolean, or a promise resolving to a boolean.
	 * @type {boolean | undefined | null | (() => boolean | Promise<boolean> | null | undefined)}
	 * @example
	 * true // Test will run
	 * () => environment === 'production' // Conditional test execution
	 */
	if:
		| boolean
		| undefined
		| null
		| (() => boolean | Promise<boolean> | null | undefined);
	/**
	 * The number of times the test should be retried upon failure.
	 * @type {number}
	 * @example 3 // Retry the test 3 times
	 */
	retry: number;
	/**
	 * Indicates whether the test should allow soft failures without halting the test suite.
	 * @type {boolean}
	 * @example true // Test can fail without breaking the suite
	 */
	softfail: boolean;
	/**
	 * Indicates whether the test should be run sequentially.
	 * @type {boolean}
	 * @example true // Test will run in sequence with others
	 */
	sequencial: boolean;
	/**
	 * Indicates whether the test is a benchmark test.
	 * @type {boolean}
	 * @example true // Marks the test as a benchmark
	 */
	bench: boolean;
	/**
	 * Indicates whether the test is marked as a 'to-do' item.
	 * @type {boolean}
	 * @example true // Test is marked as a to-do
	 */
	todo: boolean;
	/**
	 * The number of iterations the test should run.
	 * @type {number | undefined}
	 * @example 100 // Run the test 100 times
	 */
	iterations: number;
	/**
	 * The number of warmup iterations before the actual test begins.
	 * @type {number | undefined}
	 * @example 10 // Perform 10 warmup iterations before testing
	 */
	warmup: number;
	/**
	 * The confidence level for statistical calculations (between 0 and 1).
	 * Used to calculate confidence intervals for the benchmark results.
	 * Higher values mean more confidence but wider intervals.
	 * @type {number | undefined}
	 * @default 0.95
	 * @example 0.99 // Use 99% confidence level for more rigorous results
	 * @example 0.90 // Use 90% confidence level for narrower intervals
	 */
	confidence: number;
}
/**
 * Interface representing a test case and its associated methods and properties.
 */
export interface TestCase {
	/**
	 * The description of the test case.
	 * @example 'User login tests'
	 */
	description: string;
	/**
	 * Updates the description of the test case.
	 * @param description - The new description for the test case.
	 * @example testCase.should('Updated description');
	 */
	should(description: string): void;
	/**
	 * Defines a benchmark test.
	 * @param description - The description of the test.
	 * @param fn - The function to benchmark.
	 * @param options - Additional test options.
	 * @example testCase.bench('Measure performance', () => doWork());
	 */
	bench(
		description: string,
		fn: TestFunction,
		options?: Partial<Options>,
	): void;
	/**
	 * Defines a parameterized test for each entry in the provided table.
	 * @param table - An array of test data.
	 * @param description - The description template.
	 * @param fn - The test function.
	 * @param options - Additional test options.
	 * @example
	 * testCase.each([[1, 2], [3, 4]], 'adds %d and %d', (a, b) => expect(a + b).toBeGreaterThan(0));
	 */
	each(
		table: any[],
		description: string,
		fn: (...args: any[]) => void | Promise<void>,
		options?: Partial<Options>,
	): void;
	/**
	 * Defines a standard test.
	 * @param description - The description of the test.
	 * @param fn - The test function.
	 * @param options - Additional test options.
	 * @example testCase.it('should login successfully', () => login());
	 */
	it(description: string, fn: TestFunction, options?: Partial<Options>): void;
	/**
	 * Defines a test to run in sequence.
	 * @param description - The description of the test.
	 * @param fn - The test function.
	 * @param options - Additional test options.
	 * @example testCase.sequence('processes data sequentially', () => processData());
	 */
	sequence(
		description: string,
		fn: TestFunction,
		options?: Partial<Options>,
	): void;
	/**
	 * Defines a test with retry logic.
	 * @param retry - The number of retries.
	 * @param description - The description of the test.
	 * @param fn - The test function.
	 * @param options - Additional test options.
	 * @example testCase.retry(3, 'retryable test', () => flakyTest());
	 */
	retry(
		retry: number,
		description: string,
		fn: TestFunction,
		options?: Partial<Options>,
	): void;
	/**
	 * Defines a test with a timeout.
	 * @param timeout - The timeout in milliseconds.
	 * @param description - The description of the test.
	 * @param fn - The test function.
	 * @param options - Additional test options.
	 * @example testCase.timeout(5000, 'should finish within 5 seconds', () => quickTest());
	 */
	timeout(
		timeout: number,
		description: string,
		fn: TestFunction,
		options?: Partial<Options>,
	): void;
	/**
	 * Adds a todo test.
	 * @param description - The description of the test.
	 * @param options - Additional test options.
	 * @example testCase.todo('Implement this later');
	 */
	todo(description: string, options?: Partial<Options>): void;
	/**
	 * Conditionally runs a test if the condition is met.
	 * @param condition - A boolean or function returning a boolean.
	 * @param description - The description of the test.
	 * @param fn - The test function.
	 * @param options - Additional test options.
	 * @example testCase.itIf(true, 'conditionally run this test', () => doTest());
	 */
	itIf(
		condition:
			| boolean
			| undefined
			| null
			| (() => boolean | Promise<boolean> | null | undefined),
		description: string,
		fn: TestFunction,
		options?: Partial<Options>,
	): void;
	/**
	 * Marks a test to allow soft failures.
	 * @param description - The description of the test.
	 * @param fn - The test function.
	 * @param options - Additional test options.
	 * @example testCase.fail('non-critical test', () => flakyTest());
	 */
	fail(description: string, fn: TestFunction, options?: Partial<Options>): void;
	/**
	 * Marks a test to run exclusively.
	 * @param description - The description of the test.
	 * @param fn - The test function.
	 * @param options - Additional test options.
	 * @example testCase.only('critical test', () => runCriticalTest());
	 */
	only(description: string, fn: TestFunction, options?: Partial<Options>): void;
	/**
	 * Skips a test.
	 * @param description - The description of the test.
	 * @param fn - The test function.
	 * @param options - Additional test options.
	 * @example testCase.skip('skipped test', () => doNotRun());
	 */
	skip(description: string, fn: TestFunction, options?: Partial<Options>): void;
	/**
	 * Adds a 'beforeAll' hook to the test case.
	 * @param fn - The hook function.
	 * @param options - Additional options.
	 * @example testCase.beforeAll(() => setup());
	 */
	beforeAll(fn: HookFunction, options?: Partial<Options>): void;
	/**
	 * Adds a 'beforeEach' hook to the test case.
	 * @param fn - The hook function.
	 * @param options - Additional options.
	 * @example testCase.beforeEach(() => setupEach());
	 */
	beforeEach(fn: HookFunction, options?: Partial<Options>): void;
	/**
	 * Adds an 'afterAll' hook to the test case.
	 * @param fn - The hook function.
	 * @param options - Additional options.
	 * @example testCase.afterAll(() => teardown());
	 */
	afterAll(fn: HookFunction, options?: Partial<Options>): void;
	/**
	 * Adds an 'afterEach' hook to the test case.
	 * @param fn - The hook function.
	 * @param options - Additional options.
	 * @example testCase.afterEach(() => cleanupEach());
	 */
	afterEach(fn: HookFunction, options?: Partial<Options>): void;
	/**
	 * Runs the test case and returns a test report.
	 * @returns {Promise<TestReport>} The test report after execution.
	 * @example const report = await testCase.run();
	 */
	run(): Promise<TestReport>;
}
export declare class TestCase {
	description: string;
	tests: Test[];
	sequenceTests: Test[];
	sequenceOnlyTests: Test[];
	onlyTests: Test[];
	hooks: {
		beforeAll?: Hook;
		beforeEach?: Hook;
		afterAll?: Hook;
		afterEach?: Hook;
	};
	constructor(description: string);
}
export interface PoolResult {
	error: any;
	report: TestReport | null;
	duration: number;
	logs: LogEntry[];
	sourceMap: SourceMapConsumer;
}
export interface ReporterPlugin {
	reporter: Reporter;
	options?: Record<any, any>;
}
export interface Reporter {
	/** Name of the reporter plugin */
	name: string;
	/**
	 * The type of the reporter plugin.
	 *
	 * - `"file"`: Writes the report to a file.
	 * - `"console"`: Outputs the report to the console.
	 */
	type: "file" | "console";
	/**
	 * Generates a report based on the provided options.
	 *
	 * @param {Object} options - Configuration for generating the report.
	 * @param {Map<string, PoolResult>} options.reports - A map containing report data where the key is a string identifier and the value is a `PoolResult`.
	 * @param {string} [options.outputDir] - Directory where the report should be saved. Required if the plugin type is `"file"`.
	 *
	 * @example
	 * const plugin: ReporterPlugin = {
	 *   name: "FileReporter",
	 *   type: "file",
	 *   report: async (options) => {
	 *     console.log("Generating report...");
	 *     // Implementation here...
	 *   },
	 * };
	 *
	 * @returns {Promise<void>} Resolves when the report is successfully generated.
	 */
	report(options: {
		/**
		 * A map containing report data where:
		 * - The key is a unique string identifier for the report.
		 * - The value is an object of type `PoolResult`.
		 */
		reports: Map<string, PoolResult>;
		/**
		 * The directory where the report should be saved.
		 */
		outputDir?: string;
		[key: string]: any;
	}): Promise<void>;
}
/**
 * Type representing the configuration options for Veve.
 */
export interface Veve {
	/**
	 * A list of patterns to include for processing.
	 * @example ['src/app.ts', 'src/utils.tsx']
	 */
	pattern: string[];
	/**
	 * A list of patterns to exclude from processing.
	 * @example ['node_modules', 'dist']
	 */
	exclude: string[];
	/**
	 * A list of environment names where this configuration will be applied.
	 * @example ['development', 'production', 'test']
	 */
	envs: string[];
	/**
	 * A list of eabuild plugins to be used in the configuration.
	 */
	plugins: Plugin$1[];
	/**
	 * The timeout value in milliseconds for operations.
	 * @example 3000
	 */
	timeout: number;
	/**
	 * A context object that can hold any key-value pair.
	 * @example { key: 'value', flag: true }
	 */
	context: Record<any, any>;
	/**
	 * The TypeScript configuration options.
	 * @example { strict: true, baseUrl: './' }
	 */
	tsconfig: Tsconfig;
	/**
	 * Whether to watch files for changes.
	 * @example true
	 */
	watch: boolean;
	/**
	 * List of modules to auto require inside the testing files
	 * @example ["jsdom-global/register"]
	 */
	require: string[];
	/**
	 * List of reporter plugins
	 * @example ["jsdom-global/register"]
	 */
	reporters: ReporterPlugin[];
	/**
	 * Defines the file path for reporters to save their outputs.
	 * @example "./reports"
	 */
	output: string;
}
/**
 * Interface representing TypeScript configuration options.
 */
export interface Tsconfig {
	/**
	 * Whether to enforce strict mode in all files.
	 * @example true
	 */
	alwaysStrict?: boolean;
	/**
	 * The base URL for module resolution.
	 * @example './src'
	 */
	baseUrl?: string;
	/**
	 * Enables experimental decorator support.
	 * @example true
	 */
	experimentalDecorators?: boolean;
	/**
	 * Specifies how imports not used as values should be treated.
	 * @example 'remove'
	 */
	importsNotUsedAsValues?: "remove" | "preserve" | "error";
	/**
	 * Specifies the JSX code generation style.
	 * @example 'react-jsx'
	 */
	jsx?: "preserve" | "react-native" | "react" | "react-jsx" | "react-jsxdev";
	/**
	 * Factory function for creating JSX elements.
	 * @example 'React.createElement'
	 */
	jsxFactory?: string;
	/**
	 * Factory function for creating JSX fragment elements.
	 * @example 'React.Fragment'
	 */
	jsxFragmentFactory?: string;
	/**
	 * Specifies the module specifier for JSX imports.
	 * @example '@emotion/react'
	 */
	jsxImportSource?: string;
	/**
	 * A mapping of module paths to arrays of paths.
	 * @example { '@utils': ['./src/utils'] }
	 */
	paths?: Record<string, string[]>;
	/**
	 * Whether to preserve value imports in the emitted JavaScript.
	 * @example true
	 */
	preserveValueImports?: boolean;
	/**
	 * Whether to enable strict type checking options.
	 * @example true
	 */
	strict?: boolean;
	/**
	 * Whether to use `define` for class field initialization.
	 * @example true
	 */
	useDefineForClassFields?: boolean;
	/**
	 * Whether to keep the module syntax as-is in the emitted JavaScript.
	 * @example true
	 */
	verbatimModuleSyntax?: boolean;
}
declare function veve(config: Partial<Veve>): Partial<Veve>;
export interface spec extends Reporter {}
export declare const spec: spec;
export interface junit extends Reporter {}
/**
 * Generates a JUnit XML report for the provided test results.
 *
 * @returns {Promise<void>} Resolves when the XML report is successfully written to a file.
 */
export declare const junit: junit;
export interface json extends Reporter {}
/**
 * Generates a comprehensive JSON report for the provided test results.
 *
 * @returns {Promise<void>} Resolves when the JSON report is successfully written to a file.
 */
export declare const json: json;
/**
 * Represents the contract for an XML document writer.
 * Provides methods to build XML documents with support for tags, attributes, and content.
 */
export interface XML {
	/**
	 * Opens a new XML tag with optional attributes.
	 *
	 * @param name - The name of the tag
	 * @param attributes - Optional key-value pairs of attributes
	 * @returns The XMLWriter instance for method chaining
	 *
	 * @example
	 * writer.openTag('person', { id: 1, type: 'employee' })
	 */
	openTag(name: string, attributes?: Record<string, string | number>): XML;
	/**
	 * Adds a self-closing XML tag with optional attributes.
	 *
	 * @param name - The name of the tag
	 * @param attributes - Optional key-value pairs of attributes
	 * @returns The XMLWriter instance for method chaining
	 *
	 * @example
	 * writer.selfClosingTag('image', { src: 'profile.jpg', width: 100 })
	 */
	selfClosingTag(
		name: string,
		attributes?: Record<string, string | number>,
	): XML;
	/**
	 * Adds an XML tag with content and optional attributes.
	 *
	 * @param name - The name of the tag
	 * @param content - The text content of the tag
	 * @param attributes - Optional key-value pairs of attributes
	 * @returns The XMLWriter instance for method chaining
	 *
	 * @example
	 * writer.tag('name', 'John Doe', { type: 'full' })
	 */
	tag(
		name: string,
		content: string,
		attributes?: Record<string, string | number>,
	): XML;
	/**
	 * Closes the most recently opened tag.
	 *
	 * @param name - The name of the tag to close
	 * @returns The XMLWriter instance for method chaining
	 *
	 * @example
	 * writer.openTag('person').closeTag('person')
	 */
	closeTag(name: string): XML;
	/**
	 * Generates the complete XML document as a string.
	 *
	 * @returns The full XML document
	 *
	 * @example
	 * const xmlString = writer.toString();
	 */
	toString(): string;
}
export declare class XML {
	private buffer;
	private indent;
	constructor();
	private escapeXml;
}
/**
 * A class providing assertion methods for testing.
 */
export interface Assertion {
	/**
	 * Asserts that the received value is defined (not `undefined`).
	 * @returns {Assertion | boolean} Assertion result.
	 * @example
	 * assert(5).toBeDefined(); // Passes
	 * assert(undefined).toBeDefined(); // Fails
	 */
	toBeDefined(): Assertion | boolean;
	/**
	 * Checks if the received value is `undefined`
	 * @returns {Assertion | boolean} - The result of the assertion
	 * @example
	 * assert(undefined).toBeUndefined(); // Passes
	 * assert(42).toBeUndefined(); // Fails
	 */
	toBeUndefined(): Assertion | boolean;
	/**
	 * Checks if the received value is `null`
	 * @returns {Assertion | boolean} - The result of the assertion
	 * @example
	 * assert(null).toBeNull(); // Passes
	 * assert(42).toBeNull(); // Fails
	 */
	toBeNull(): Assertion | boolean;
	/**
	 * Checks if the received value evaluates to `true` in a boolean context
	 * @returns {Assertion | boolean} - The result of the assertion
	 * @example
	 * assert(1).toBeTruthy(); // Passes
	 * assert(false).toBeTruthy(); // Fails
	 */
	toBeTruthy(): Assertion | boolean;
	/**
	 * Asserts that the received value is falsy (evaluates to `false` in a boolean context).
	 * @returns {Assertion | boolean} Assertion result.
	 * @example
	 * assert(false).toBeFalsy(); // Passes
	 * assert(1).toBeFalsy(); // Fails
	 */
	toBeFalsy(): Assertion | boolean;
	/**
	 * Asserts that the received value is greater than the expected value.
	 * @param {number | bigint} expected - The expected value.
	 * @returns {Assertion | boolean} Assertion result.
	 * @example
	 * assert(5).toBeGreaterThan(3); // Passes
	 * assert(1).toBeGreaterThan(5); // Fails
	 */
	toBeGreaterThan(expected: number | bigint): Assertion | boolean;
	/**
	 * Checks if the received value is greater than or equal to the expected value
	 * @param {number | bigint} expected - The value to compare against
	 * @returns {Assertion | boolean} - The result of the assertion
	 * @example
	 * assert(10).toBeGreaterThanOrEqual(10); // Passes
	 * assert(5).toBeGreaterThanOrEqual(10); // Fails
	 */
	toBeGreaterThanOrEqual(expected: number | bigint): Assertion | boolean;
	/**
	 * Checks if the received value is less than the expected value
	 * @param {number | bigint} expected - The value to compare against
	 * @returns {Assertion | boolean} - The result of the assertion
	 * @example
	 * assert(5).toBeLessThan(10); // Passes
	 * assert(10).toBeLessThan(5); // Fails
	 */
	toBeLessThan(expected: number | bigint): Assertion | boolean;
	/**
	 * Checks if the received value is an instance of the given class or constructor
	 * @param {Function} expectedClass - The class or constructor to check against
	 * @returns {Assertion | boolean} - The result of the assertion
	 * @example
	 * assert(new Date()).toBeInstanceOf(Date); // Passes
	 * assert({}).toBeInstanceOf(Date); // Fails
	 */
	toBeInstanceOf(expectedClass: (...args: any) => any): Assertion | boolean;
	/**
	 * Checks if the received value is less than or equal to the expected value
	 * @param {number | bigint} expected - The value to compare against
	 * @returns {Assertion | boolean} - The result of the assertion
	 * @example
	 * assert(10).toBeLessThanOrEqual(10); // Passes
	 * assert(15).toBeLessThanOrEqual(10); // Fails
	 */
	toBeLessThanOrEqual(expected: number | bigint): Assertion | boolean;
	/**
	 * Checks if a value is `NaN`.
	 * @returns {Assertion | boolean} Assertion result.
	 * @example
	 * assert(NaN).toBeNaN(); // Passes
	 * assert(5).toBeNaN(); // Fails
	 */
	toBeNaN(): Assertion | boolean;
	/**
	 * Asserts that the received value matches the provided regular expression or string.
	 * @param {RegExp | string} expected - The expected pattern.
	 * @returns {Assertion | boolean} Assertion result.
	 * @example
	 * assert("hello").toMatch(/he/); // Passes
	 * assert("world").toMatch("wor"); // Passes
	 */
	toMatch(expected: RegExp | string): Assertion | boolean;
	/**
	 * Checks if the received value is strictly equal to the expected value
	 * @param {any} expected - The value to compare against
	 * @returns {Assertion | boolean} Assertion result
	 * @example
	 * // Passes
	 * assert(5).toBe(5)
	 *
	 * // Fails
	 * assert(5).toBe(6)
	 */
	toBe(expected: any): Assertion | boolean;
	/**
	 * Checks if the received value is strictly between the min and max (exclusive).
	 * @param {number | bigint} min - The lower bound (exclusive).
	 * @param {number | bigint} max - The upper bound (exclusive).
	 * @returns {Assertion | boolean} Assertion result.
	 * @example
	 * // Passes
	 * assert(15).toBeBetween(10, 20);
	 *
	 * // Fails
	 * assert(15).toBeBetween(15, 20);
	 */
	toBeBetween(min: number | bigint, max: number | bigint): Assertion | boolean;
	/**
	 * Checks if the received value is between the min and max (inclusive).
	 * @param {number | bigint} min - The lower bound (inclusive).
	 * @param {number | bigint} max - The upper bound (inclusive).
	 * @returns {Assertion | boolean} Assertion result.
	 * @example
	 * // Passes
	 * assert(15).toBeBetweenOrEqual(10, 15);
	 *
	 * // Fails
	 * assert(15).toBeBetweenOrEqual(16, 20);
	 */
	toBeBetweenOrEqual(
		min: number | bigint,
		max: number | bigint,
	): Assertion | boolean;
	/**
	 * Checks if the received value is greater than or equal to the min value.
	 * @param {number | bigint} min - The minimum value (inclusive).
	 * @returns {Assertion | boolean} Assertion result.
	 * @example
	 * // Passes
	 * assert(15).toBeAboveMin(10);
	 *
	 * // Fails
	 * assert(5).toBeAboveMin(10);
	 */
	toBeAboveMin(min: number | bigint): Assertion | boolean;
	/**
	 * Checks if the received value is less than or equal to the max value.
	 * @param {number | bigint} max - The maximum value (inclusive).
	 * @returns {Assertion | boolean} Assertion result.
	 * @example
	 * // Passes
	 * assert(15).toBeBelowMax(20);
	 *
	 * // Fails
	 * assert(25).toBeBelowMax(20);
	 */
	toBeBelowMax(max: number | bigint): Assertion | boolean;
	/**
	 * Asserts that the received value is deeply equal to the expected value.
	 * - Performs a deep comparison between the received and expected values,
	 *   checking all nested properties for equality.
	 * - Suitable for comparing objects, arrays, and primitives.
	 *
	 * @param {any} expected - The value to compare against the received value.
	 * @returns {Assertion | boolean} - Returns an Assertion instance or a boolean depending on configuration.
	 *
	 * @example
	 * // Objects with the same structure pass
	 * assert({ a: 1, b: { c: 2 } }).toEqual({ a: 1, b: { c: 2 } }); // Passes
	 *
	 * // Arrays with the same elements pass
	 * assert([1, 2, 3]).toEqual([1, 2, 3]); // Passes
	 *
	 * // Primitives with the same value pass
	 * assert(42).toEqual(42); // Passes
	 */
	toEqual(expected: any): Assertion | boolean;
	/**
	 * Checks if the received value contains the expected value.
	 * - For arrays, it checks if the array includes the expected value.
	 * - For strings, it checks if the string includes the expected substring.
	 *
	 * @param {any} expected - The value to check for in the received value.
	 * @returns {Assertion | boolean} - The result of the assertion.
	 * @example
	 * assert([1, 2, 3]).toContain(2); // Passes
	 * assert("hello world").toContain("world"); // Passes
	 * assert([1, 2, 3]).toContain(5); // Fails
	 */
	toContain(expected: any): Assertion | boolean;
	/**
  Asserts that a tracked function throws an exception that matches the expected value.
   * This method checks the last exception thrown by a tracked function and compares it with the expected exception.
   * If the exception does not match, it will display the differences between the thrown exception and the expected one.
   *
   * If no exceptions are thrown, it will fail the assertion with a message: "No exceptions were thrown!".
   * If an exception is thrown, it compares the exception with the expected value and reports any differences.
   *
   * @param {any} expected - The expected exception or value to compare against the thrown exception.
   * This could be an exact match or a complex object that will be compared with the thrown exception.
   *
   * @throws {Error} Throws an error if the function is not being tracked or if the exception does not match the expected value.
   *
   * @returns {boolean} Returns `true` if the exception matches the expected value (no differences), otherwise returns `false` and logs the exception differences.
   *
   * @example
   * assert(() => { throw new Error("Expected error") }).toThrow("Expected error") // Passes
   */
	toThrow(expected: any): Assertion | boolean;
	/**
	 * Checks if the number is close to another number within a specified precision
	 * @param {number} expected - Expected number
	 * @param {number} [numDigits=2] - Number of decimal places to compare
	 * @returns {Assertion | boolean} Assertion result
	 * @example
	 * assert(3.14159).toBeCloseTo(Math.PI, 2)
	 */
	toBeCloseTo(expected: number, numDigits?: number): Assertion | boolean;
	/**
	 * Checks if the received function has been called
	 * @returns {Assertion | boolean} Assertion result
	 * @throws {Error} If received is not a tracked function
	 * @example
	 * const mockFn = Fn(() => {});
	 * mockFn();
	 * assert(mockFn).toHaveBeenCalled()
	 */
	toBeTracked(): Assertion | boolean;
	/**
	 * Checks if the received function has been called
	 * @returns {Assertion | boolean} Assertion result
	 * @throws {Error} If received is not a tracked function
	 * @example
	 * const mockFn = Fn(() => {});
	 * mockFn();
	 * assert(mockFn).toHaveBeenCalled()
	 */
	toHaveBeenCalled(): Assertion | boolean;
	/**
	 * Checks if the received function has been called exactly n times
	 * @param {number} times - Number of expected calls
	 * @returns {Assertion | boolean} Assertion result
	 * @throws {Error} If received is not a tracked function
	 * @example
	 * const mockFn = Fn(() => {});
	 * mockFn();
	 * mockFn();
	 * assert(mockFn).toHaveBeenCalledTimes(2)
	 */
	toHaveBeenCalledTimes(times: number): Assertion | boolean;
	/**
	 * Checks if the received function was called with specific arguments
	 * @param {...any} args - Arguments to check
	 * @returns {Assertion | boolean} Assertion result
	 * @throws {Error} If received is not a tracked function
	 * @example
	 * const mockFn = Fn((a: number, b: string) => {});
	 * mockFn(42, "hello");
	 * assert(mockFn).toHaveBeenCalledWith(42, "hello")
	 */
	toHaveBeenCalledWith(...args: any[]): Assertion | boolean;
	/**
	 * Checks if the function was last called with specific arguments
	 * @param {...any} args - Arguments to check for the last call
	 * @returns {Assertion | boolean} Assertion result
	 * @throws {Error} If received is not a tracked function
	 * @example
	 * const mockFn = Fn((a: number) => {});
	 * mockFn(1);
	 * mockFn(2);
	 * assert(mockFn).toHaveBeenLastCalledWith(2)
	 */
	toHaveBeenLastCalledWith(...args: any[]): Assertion | boolean;
	/**
	 * Checks if the nth call of the function was with specific arguments
	 * @param {number} n - The call number to check (1-indexed)
	 * @param {...any} args - Arguments to check for the nth call
	 * @returns {Assertion | boolean} Assertion result
	 * @throws {Error} If received is not a tracked function
	 * @example
	 * const mockFn = Fn((a: number) => {});
	 * mockFn(1);
	 * mockFn(2);
	 * mockFn(3);
	 * assert(mockFn).toHaveBeenNthCalledWith(2, 2)
	 */
	toHaveBeenNthCalledWith(n: number, ...args: any[]): Assertion | boolean;
	/**
	 * Checks if the function has returned at least once
	 * @returns {Assertion | boolean} Assertion result
	 * @throws {Error} If received is not a tracked function
	 * @example
	 * const mockFn = Fn(() => 42);
	 * mockFn();
	 * assert(mockFn).toHaveReturned()
	 */
	toHaveReturned(): Assertion | boolean;
	/**
	 * Checks if the function has returned exactly n times
	 * @param {number} times - Number of expected returns
	 * @returns {Assertion | boolean} Assertion result
	 * @throws {Error} If received is not a tracked function
	 * @example
	 * const mockFn = Fn(() => 42);
	 * mockFn();
	 * mockFn();
	 * assert(mockFn).toHaveReturnedTimes(2)
	 */
	toHaveReturnedTimes(times: number): Assertion | boolean;
	/**
	 * Checks if the function has returned with a specific value
	 * @param {any} value - The value to check for in return values
	 * @returns {Assertion | boolean} Assertion result
	 * @throws {Error} If received is not a tracked function
	 * @example
	 * const mockFn = Fn(() => 42);
	 * mockFn();
	 * assert(mockFn).toHaveReturnedWith(42)
	 */
	toHaveReturnedWith(value: any): Assertion | boolean;
	/**
	 * Checks if the function's last return was a specific value
	 * @param {any} value - The value to check for in the last return
	 * @returns {Assertion | boolean} Assertion result
	 * @throws {Error} If received is not a tracked function
	 * @example
	 * const mockFn = Fn(() => 42);
	 * mockFn();
	 * mockFn();
	 * assert(mockFn).toHaveLastReturnedWith(42)
	 */
	toHaveLastReturnedWith(value: any): Assertion | boolean;
	/**
	 * Checks if the nth return of the function was a specific value
	 * @param {number} n - The return number to check (1-indexed)
	 * @param {any} value - The value to check for in the nth return
	 * @returns {Assertion | boolean} Assertion result
	 * @throws {Error} If received is not a tracked function
	 * @example
	 * const mockFn = Fn(() => 42);
	 * mockFn();
	 * mockFn();
	 * assert(mockFn).toHaveNthReturnedWith(2, 42)
	 */
	toHaveNthReturnedWith(n: number, value: any): Assertion | boolean;
	/**
	 * Checks if the received value has a specific length
	 * @param {number} length - Expected length
	 * @returns {Assertion | boolean} Assertion result
	 * @example
	 * assert([1, 2, 3]).toHaveLength(3)
	 * assert("hello").toHaveLength(5)
	 */
	toHaveLength(length: number): Assertion | boolean;
	/**
	 * Checks if the received object has a specific property with an optional value
	 * @param {string} keyPath - Dot-notation path to the property
	 * @param {any} [value] - Optional expected value of the property
	 * @returns {Assertion | boolean} Assertion result
	 * @example
	 * assert({ a: { b: 42 } }).toHaveProperty('a.b', 42)
	 * assert({ x: 1 }).toHaveProperty('x')
	 */
	toHaveProperty(keyPath: string, value?: any): Assertion | boolean;
}
export declare class Assertion {
	received: any;
	isNot: boolean;
	isTracked: boolean;
	throws: boolean;
	constructor(received: any, throws: boolean);
	get not(): this;
	get resolves(): this;
	get rejects(): this;
	private assert;
}
/**
 * Creates a new assertion instance for the provided value.
 * - This function performs assertions that will **throw an error** if the condition fails.
 * - Use this when you need hard failure handling for invalid conditions.
 *
 * @param {any} received - The value to be asserted.
 * @example
 * assert(42).toBe(42); // Passes
 * assert("hello").toBe("world"); // Throws an error
 * @returns {Assertion} An `Assertion` instance configured to throw errors on failure.
 */
export declare function assert(received: any): Assertion;
/**
 * Creates a new assertion instance for the provided value.
 * - This function performs non-throwing assertions, which do not raise errors on failure.
 * - Use this for scenarios where you want to test conditions without interrupting execution.
 *
 * @param {any} received - The value to be strictly asserted.
 * @example
 * is(42).toBe(42); // Passes
 * is("hello").toBe("world"); // Does not throw, but marks failure
 * @returns {Assertion} An `Assertion` instance configured to silently handle failures.
 */
export declare function is(received: any): Assertion;
export type MethodNames<T> = {
	[K in keyof T]: T[K] extends (...args: any[]) => any ? K : never;
}[keyof T];
export type TrackedFunction<T extends (...args: any[]) => any> = T & TrackFn;
export type MethodType<T, K extends keyof T> = T[K] extends (
	...args: any[]
) => any
	? T[K]
	: never;
/**
 * Interface representing a tracking function with utilities for inspecting calls, arguments, and results.
 * @template T - The arguments of the tracked function, defaults to any[].
 * @template R - The return type of the tracked function, defaults to any.
 */
export interface TrackFn {
	/**
	 * Retrieves all the function calls made to the tracked function.
	 * @returns {ReadonlyArray<FunctionCall>} An array of recorded function calls.
	 * @example trackFn.getCalls();
	 */
	getCalls(): ReadonlyArray<FunctionCall>;
	/**
	 * Retrieves a specific function call by index.
	 * @param {number} index - The index of the function call.
	 * @returns {FunctionCall | undefined} The function call at the specified index, or undefined if not found.
	 * @example trackFn.getCall(0);
	 */
	getCall(index: number): FunctionCall | undefined;
	/**
	 * Retrieves the most recent function call made to the tracked function.
	 * @returns {FunctionCall | undefined} The latest function call, or undefined if no calls have been made.
	 * @example trackFn.getLatestCall();
	 */
	getLatestCall(): FunctionCall | undefined;
	/**
	 * Retrieves the total number of times the tracked function has been called.
	 * @returns {number} The total call count.
	 * @example trackFn.getCallCount();
	 */
	getCallCount(): number;
	/**
	 * Retrieves the arguments passed to all function calls.
	 * @returns {ReadonlyArray<any[]>} An array of arguments for each call.
	 * @example trackFn.getAllArgs();
	 */
	getAllArgs(): ReadonlyArray<any[]>;
	/**
	 * Retrieves the arguments passed to a specific function call by index.
	 * @param {number} index - The index of the function call.
	 * @returns {any[] | undefined} The arguments for the specified call, or undefined if not found.
	 * @example trackFn.getArgsForCall(1);
	 */
	getArgsForCall(index: number): any[] | undefined;
	/**
	 * Retrieves the return values of all function calls.
	 * @returns {ReadonlyArray<any>} An array of return values.
	 * @example trackFn.getReturnValues();
	 */
	getReturnValues(): ReadonlyArray<any>;
	/**
	 * Retrieves the exceptions thrown during function calls.
	 * @returns {ReadonlyArray<FunctionException>} An array of thrown exceptions.
	 * @example trackFn.getExceptions();
	 */
	getExceptions(): ReadonlyArray<FunctionException>;
	/**
	 * Checks if the tracked function was called at least once.
	 * @returns {boolean} True if the function was called, otherwise false.
	 * @example trackFn.wasCalled();
	 */
	wasCalled(): boolean;
	/**
	 * Checks if the tracked function was called with specific arguments.
	 * @param {...any[]} args - The arguments to check.
	 * @returns {boolean} True if the function was called with the specified arguments, otherwise false.
	 * @example trackFn.wasCalledWith('arg1', 'arg2');
	 */
	wasCalledWith(...args: any[]): boolean;
	/**
	 * Checks if the tracked function was called a specific number of times.
	 * @param {number} n - The number of calls to check.
	 * @returns {boolean} True if the function was called exactly n times, otherwise false.
	 * @example trackFn.wasCalledTimes(3);
	 */
	wasCalledTimes(n: number): boolean;
	/**
	 * Sets the return value for the tracked function.
	 * @param {any} value - The value to be returned.
	 * @returns {TrackFn} The updated tracked function.
	 * @example trackFn.return('value');
	 */
	return(value: any): TrackFn;
	/**
	 * Configures the tracked function to throw a specific error.
	 * @param {Error} error - The error to be thrown.
	 * @returns {TrackFn} The updated tracked function.
	 * @example trackFn.throw(new Error('Something went wrong'));
	 */
	throw(error: Error): TrackFn;
	/**
	 * Replaces the tracked function with a custom implementation.
	 * @param {Function} fn - The custom function to use.
	 * @returns {TrackFn} The updated tracked function.
	 * @example trackFn.use((arg1, arg2) => arg1 + arg2);
	 */
	use<A extends any[], R>(fn: (...args: A) => R): TrackFn;
	/**
	 * Resets the state of the tracked function, clearing all recorded calls, arguments, and results.
	 * @returns {TrackFn} The reset tracked function.
	 * @example trackFn.reset();
	 */
	reset(): TrackFn;
	/**
	 * Clears all recorded calls and arguments but retains custom behavior configurations.
	 * @returns {TrackFn} The cleared tracked function.
	 * @example trackFn.clear();
	 */
	clear(): TrackFn;
}
export interface FunctionCall {
	args: any[];
	timestamp: Date;
	result: any;
}
export interface FunctionException {
	error: Error;
	timestamp: Date;
}
export declare class TrackFn implements TrackFn {
	private _implementation;
	private _calls;
	private _returnValues;
	private _exceptions;
	private _callCount;
	private _instances;
	constructor(_implementation: (...args: any[]) => any);
	track: () => (...args: any[]) => any;
	private recordCall;
	private recordException;
	returns(value: any): TrackFn;
	throws(error: Error): TrackFn;
}
/**
 * Checks if a value is a tracked function.
 *
 * @param {any} value - The value to check.
 * @returns {boolean} True if the value is a tracked function, otherwise false.
 *
 * @example
 * const trackedAdd = Fn((a: number, b: number) => a + b);
 * console.log(isFn(trackedAdd)); // true
 */
export declare function isFn(value: any): boolean;

/**
 * Creates a tracked version of a given function, preserving its original type signature while
 * adding tracking capabilities. The returned function maintains the same behavior as the original
 * while providing additional methods for tracking calls, arguments, and results.
 *
 * @template T - The type of the function being tracked, must extend (...args: any[]) => any
 * @param {T} implementation - The original function implementation to track
 * @returns {TrackedFunction<T>} A function that combines the original implementation with tracking capabilities
 *
 * @example
 * // Track a simple addition function
 * const add = (a: number, b: number) => a + b;
 * const trackedAdd = Fn(add);
 * trackedAdd(1, 2); // Returns 3
 * console.log(trackedAdd.getCallCount()); // Returns 1
 *
 * @example
 * // Track an async function
 * const fetchData = async (id: string) => ({ id, data: 'some data' });
 * const trackedFetch = Fn(fetchData);
 * await trackedFetch('123');
 * console.log(trackedFetch.getAllArgs()); // Returns [['123']]
 *
 * @example
 * // Modify tracked function behavior
 * const greet = (name: string) => `Hello ${name}`;
 * const trackedGreet = Fn(greet);
 * trackedGreet.return('Fixed response');
 * console.log(trackedGreet('Alice')); // Returns 'Fixed response'
 */
export declare function Fn<T extends (...args: any[]) => any>(
	implementation: T,
): TrackedFunction<T>;
/**
 * Replaces a method on an object with a tracked version while preserving its original type signature.
 * The original method is replaced with a tracked version that maintains the same behavior but provides
 * additional tracking capabilities. The tracked version is both assigned to the object and returned
 * for convenience.
 *
 * @template T - The type of the object containing the method to track
 * @template K - The key type of the method to track, must be a key of T
 * @param {T} obj - The object containing the method to track
 * @param {K & MethodNames<T>} method - The name of the method to track
 * @returns {TrackedFunction<MethodType<T, K>>} A tracked version of the specified method
 * @throws {Error} If the specified method doesn't exist on the object or isn't a function
 *
 * @example
 * // Track a method on a simple object
 * const calculator = {
 *   add: (a: number, b: number) => a + b
 * };
 * const trackedAdd = spyOn(calculator, 'add');
 * calculator.add(2, 3); // Returns 5
 * console.log(trackedAdd.getCallCount()); // Returns 1
 *
 * @example
 * // Track and modify method behavior
 * const api = {
 *   fetch: async (url: string) => ({ data: 'response' })
 * };
 * const trackedFetch = spyOn(api, 'fetch');
 * trackedFetch.throw(new Error('Network error'));
 * try {
 *   await api.fetch('/data');
 * } catch (error) {
 *   console.log(error.message); // Prints: Network error
 * }
 */
export declare function spyOn<T extends object, K extends keyof T>(
	obj: T,
	method: K & MethodNames<T>,
): TrackedFunction<MethodType<T, K>>;

export { veve as default };

export {};
